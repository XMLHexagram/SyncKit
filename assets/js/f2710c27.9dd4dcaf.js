(self.webpackChunkdocs_synckit=self.webpackChunkdocs_synckit||[]).push([[5403],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return c},kt:function(){return u}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),d=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=d(e.components);return r.createElement(s.Provider,{value:t},e.children)},g={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=d(n),u=a,m=p["".concat(s,".").concat(u)]||p[u]||g[u]||i;return n?r.createElement(m,o(o({ref:t},c),{},{components:n})):r.createElement(m,o({ref:t},c))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var d=2;d<i;d++)o[d]=n[d];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},8717:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return d},toc:function(){return c},default:function(){return p}});var r=n(2122),a=n(9756),i=(n(7294),n(3905)),o=["components"],l={id:"migrating",title:"Migrating from SyncKit 0.3.0"},s="Migrating from SyncKit 0.3.0",d={unversionedId:"migrating",id:"migrating",isDocsHomePage:!1,title:"Migrating from SyncKit 0.3.0",description:"If you were using SyncKit before 0.3.0 and you want to adopt the QSPrimaryKey protocol this page offers some guidance. There are different methods that you could adopt based on your app.",source:"@site/docs/migrating.md",sourceDirName:".",slug:"/migrating",permalink:"/SyncKit/migrating",version:"current",frontMatter:{id:"migrating",title:"Migrating from SyncKit 0.3.0"},sidebar:"docs",previous:{title:"SyncKit for Core Data",permalink:"/SyncKit/coredata"},next:{title:"SyncKit for Realm",permalink:"/SyncKit/realm"}},c=[{value:"Existing primary key",id:"existing-primary-key",children:[]},{value:"Adding primary key field in your model",id:"adding-primary-key-field-in-your-model",children:[]},{value:"Discarding current SyncKit tracking data",id:"discarding-current-synckit-tracking-data",children:[]}],g={toc:c};function p(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},g,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"migrating-from-synckit-030"},"Migrating from SyncKit 0.3.0"),(0,i.kt)("p",null,"If you were using SyncKit before 0.3.0 and you want to adopt the ",(0,i.kt)("inlineCode",{parentName:"p"},"QSPrimaryKey")," protocol this page offers some guidance. There are different methods that you could adopt based on your app."),(0,i.kt)("h2",{id:"existing-primary-key"},"Existing primary key"),(0,i.kt)("p",null,"If your objects already had a populated primary key: Make them implement ",(0,i.kt)("inlineCode",{parentName:"p"},"QSPrimaryKey")," and call ",(0,i.kt)("inlineCode",{parentName:"p"},"updateTrackingForObjectsWithPrimaryKey")," on the change manager to make it update its object tracking data so it uses the primary key."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Add the ",(0,i.kt)("inlineCode",{parentName:"li"},"+ (nonnull NSString *)primaryKey")," to your classes."),(0,i.kt)("li",{parentName:"ol"},"Update tracking data:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"\n    // After launching your app, maybe in didFinishLaunchingWithOptions\n    [self.synchronizer.changeManager updateTrackingForObjectsWithPrimaryKey];\n")),(0,i.kt)("ol",{start:3},(0,i.kt)("li",{parentName:"ol"},"Now you can use SyncKit.")),(0,i.kt)("h2",{id:"adding-primary-key-field-in-your-model"},"Adding primary key field in your model"),(0,i.kt)("p",null,"If you need to change your model to add a primary key then this will require a migration, which would break all the tracking data in SyncKit. To avoid that you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"QSEntityIdentifierUpdateMigrationPolicy")," as the policy in your mapping model, then call ",(0,i.kt)("inlineCode",{parentName:"p"},"[QSCloudKitSynchronizer updateIdentifierMigrationPolicy];")," before starting the migration."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Update your CoreData model and add the required field to those model objects that might need one."),(0,i.kt)("li",{parentName:"ol"},"Create a Core Data mapping model and add entity mappings for you entities."),(0,i.kt)("li",{parentName:"ol"},"In your mapping model, specify ",(0,i.kt)("inlineCode",{parentName:"li"},"QSEntityIdentifierUpdateMigrationPolicy")," as the Custom Policy. This policy will assign a primary key value to each object being migrated."),(0,i.kt)("li",{parentName:"ol"},"When you create your Core Data stack, check if you need to perform a migration. Sample code:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"- (MigrationNeededEnum)isMigrationNecessaryForStore:(NSString *)storePath\n{\n    if (![[NSFileManager defaultManager] fileExistsAtPath:self.storePath]) {\n        return NO;\n    }\n    \n    NSError *error = nil;\n    NSDictionary *sourceMetadata = [NSPersistentStoreCoordinator metadataForPersistentStoreOfType:NSSQLiteStoreType\n                                                                                              URL:[NSURL fileURLWithPath:storePath]\n                                                                                          options:@{NSInferMappingModelAutomaticallyOption: @YES,                                  NSMigratePersistentStoresAutomaticallyOption: @YES}\n                                                                                            error:&error];\n\n    NSManagedObjectModel *destinationModel = self.coordinator.managedObjectModel;\n    if ([destinationModel isConfiguration:nil compatibleWithStoreMetadata:sourceMetadata]) {\n        return MigrationOptionNoMigration;\n    }\n    \n    NSManagedObjectModel *sourceModel = [NSManagedObjectModel mergedModelFromBundles:@[[NSBundle mainBundle]] forStoreMetadata:sourceMetadata];\n    \n    if ([NSMappingModel inferredMappingModelForSourceModel:sourceModel destinationModel:destinationModel error:&error]) {\n        return MigrationOptionLightweightMigration;\n    }\n    \n    return MigrationOptionCustomMigration;\n}\n")),(0,i.kt)("ol",{start:5},(0,i.kt)("li",{parentName:"ol"},"Perform migration. Sample code:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'- (void)performBackgroundManagedMigrationForStore:(NSString *)sourceStore\n{\n    //Show UI\n    // Show some modal screen with some UIActivityIndicatorView or similar\n    \n    // Determine if this migration is being run to adopt primary keys, maybe checking [NSManagedObjectModel versionIdentifiers] if you\'ve been setting those on your model\n    if (useSyncKitMigrationPolity) {\n        [QSCloudKitSynchronizer updateIdentifierMigrationPolicy];\n    }\n    \n    // Perform migration in the background, so it doesn\'t freeze the UI.\n    // This way progress can be shown to the user\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), ^{\n        BOOL done = [self migrateStore:sourceStore];\n        if(done) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                if (useSyncKitMigrationPolity) {\n                    [QSEntityIdentifierUpdateMigrationPolicy setCoreDataStack:nil];\n                }\n                \n                // Dismiss UI\n                // Load your persistent store\n                [self loadStore];\n            });\n        }\n    });\n}\n\n- (BOOL)migrateStore:(NSString *)sourceStore\n{\n    BOOL success = NO;\n    NSError *error = nil;\n    \n    // STEP 1 - Gather the Source, Destination and Mapping Model\n    NSURL *storeURL = [NSURL fileURLWithPath:sourceStore];\n    NSDictionary *sourceMetadata = [NSPersistentStoreCoordinator metadataForPersistentStoreOfType:NSSQLiteStoreType URL:storeURL options:nil error:&error];\n    NSManagedObjectModel *sourceModel = [NSManagedObjectModel mergedModelFromBundles:nil forStoreMetadata:sourceMetadata];\n    NSManagedObjectModel *destinationModel = self.model;\n    NSMappingModel *mappingModel = [NSMappingModel mappingModelFromBundles:nil forSourceModel:sourceModel destinationModel:destinationModel];\n    \n    // STEP 2 - Perform migration, assuming the mapping model isn\'t null\n    if (mappingModel) {\n        NSError *error = nil;\n        NSMigrationManager *migrationManager = [[NSMigrationManager alloc] initWithSourceModel:sourceModel destinationModel:destinationModel];\n        [migrationManager addObserver:self forKeyPath:@"migrationProgress" options:NSKeyValueObservingOptionNew context:NULL];\n        \n        NSString *destinationStorePath = [[self applicationStoresPath] stringByAppendingPathComponent:@"Temp.sqlite"];\n        \n        success = [migrationManager migrateStoreFromURL:storeURL\n                                                   type:NSSQLiteStoreType\n                                                options:nil\n                                       withMappingModel:mappingModel\n                                       toDestinationURL:[NSURL fileURLWithPath:destinationStorePath]\n                                        destinationType:NSSQLiteStoreType\n                                     destinationOptions:nil\n                                                  error:&error];\n        \n        [migrationManager removeObserver:self forKeyPath:@"migrationProgress"];\n        \n        if (success) {\n            // STEP 3 - Replace the old store files with the new migrated store files\n            [self replaceStore:sourceStore withStore:destinationStorePath];\n        }\n        else {\n            NSLog(@"FAILED MIGRATION: %@",error);\n        }\n    }\n    else {\n        NSLog(@"FAILED MIGRATION: Mapping Model is null");\n    }\n    return YES; // indicates migration has finished, regardless of outcome\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context\n{\n    if ([object isKindOfClass:[NSMigrationManager class]]) {\n        CGFloat progress = [(NSMigrationManager *)object migrationProgress];\n        dispatch_async(dispatch_get_main_queue(), ^{\n            // Update progress indicator UI\n        });\n    }\n}\n\n- (BOOL)replaceStore:(NSString *)old withStore:(NSString *)newPath {\n    \n    BOOL success = NO;\n    NSError *error = nil;\n    \n    if ([[NSFileManager defaultManager] fileExistsAtPath:old]) {\n        [[NSFileManager defaultManager] removeItemAtPath:old error:&error];\n        \n        NSString *walPath = [old stringByAppendingString:@"-wal"];\n        if ([[NSFileManager defaultManager] fileExistsAtPath:walPath]) {\n            [[NSFileManager defaultManager] removeItemAtPath:walPath error:&error];\n        }\n        NSString *shmPath = [old stringByAppendingString:@"-shm"];\n        if ([[NSFileManager defaultManager] fileExistsAtPath:shmPath]) {\n            [[NSFileManager defaultManager] removeItemAtPath:shmPath error:&error];\n        }\n        \n        error = nil;\n        if ([[NSFileManager defaultManager] moveItemAtPath:newPath toPath:old error:&error]) {\n            NSString *newWalPath = [newPath stringByAppendingString:@"-wal"];\n            [[NSFileManager defaultManager] moveItemAtPath:newWalPath toPath:walPath error:&error];\n            NSString *newShmPath = [newPath stringByAppendingString:@"-shm"];\n            [[NSFileManager defaultManager] moveItemAtPath:newShmPath toPath:shmPath error:&error];\n            success = YES;\n        }\n    }\n    \n    return success;\n}\n')),(0,i.kt)("ol",{start:6},(0,i.kt)("li",{parentName:"ol"},"You can now create your ",(0,i.kt)("inlineCode",{parentName:"li"},"QSCloudKitSynchronizer")," and use it to sync.")),(0,i.kt)("h2",{id:"discarding-current-synckit-tracking-data"},"Discarding current SyncKit tracking data"),(0,i.kt)("p",null,"A less optimal, though easier option would be discarding all your existing data when the app performs a migration to add primary key fields, then synchronizing with an empty NSPersistentStore to restore using data currently on iCloud."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Discard all SyncKit data: ")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"[self.synchronizer eraseLocal];\n")),(0,i.kt)("p",null,"or, alternatively, delete everything in ",(0,i.kt)("inlineCode",{parentName:"p"},"[QSCloudKitSynchronizer storePath]")),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"Delete your store file."),(0,i.kt)("li",{parentName:"ol"},"Create a new Core Data stack."),(0,i.kt)("li",{parentName:"ol"},"Create a new ",(0,i.kt)("inlineCode",{parentName:"li"},"QSCloudKitSynchronizer"),"."),(0,i.kt)("li",{parentName:"ol"},"Sync. This will download all the data in iCloud to the new, empty store, so at the end of this the local stack will be a copy of the data on iCloud.")))}p.isMDXComponent=!0}}]);